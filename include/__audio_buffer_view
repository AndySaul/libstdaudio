// libstdaudio
// Copyright (c) 2018 - Timur Doumler

#pragma once
#include <__audio_strided_span>
#include <__audio_buffer>

_LIBSTDAUDIO_NAMESPACE_BEGIN

/** A read-only collection view of a ​buffer​ that is crafted such that it iterates
 *  over the channels or frames of the underlying buffer as appropriate.
 *  Note that it is not actually a container because it returns by value rather
 *  than by reference. The type that it returns is itself a collection view into
 *  the underlying buffer, which means that it does not own the data.
 *
 *  buffer_view is not instantiable by the user. The only way to obtain an instance
 *  of a buffer_view is by calling buffer::channels() or buffer::frames().
 */
template <buffer_view_type _Type>
class buffer_view
{
public:
  using value_type = strided_span<sample_type>;
  using index_type = ptrdiff_t;

  buffer_view(const buffer& buf) noexcept
    : _buf(buf){
  }

  index_type size() const noexcept {
    return _Type == buffer_view_type::channels
      ? _buf._num_channels
      : _buf._num_channels == 0 ? 0 : _buf._data.size() / _buf._num_channels;
  }

  bool empty() const noexcept {
    return _buf.empty();
  }

  value_type operator[](index_type index) {
    if constexpr (_Type == buffer_view_type::channels) {
      if (_buf.get_order() == buffer_order::interleaved) {
        const auto stride = _buf._num_channels;
        const auto size = _buf._data.size();
        return {_buf._data.data() + index, size, stride};
      }
      else {
        const auto offset = index * _buf._data.size() / _buf._num_channels;
        const auto size = _buf._data.size() / _buf._num_channels;
        return {_buf._data.data() + offset, size, 1};
      }
    }
    else {
      if (_buf.get_order() == buffer_order::interleaved) {
        const auto offset = index * _buf._num_channels;
        const auto size = _buf._num_channels;
        return {_buf._data.data() + offset, size, 1};
      }
      else {
        const auto stride = _buf._data.size() / _buf._num_channels;
        const auto size = _buf._data.size();
        return {_buf._data.data() + index, size, stride};
      }
    }
  }

  value_type at() {
    // TODO: throw  std::out_of_range, add tests, and also add this to strided_span
    return {};
  }

  class iterator
  {

  };

  iterator begin() {
    // TODO: implement
    return {};
  }

  iterator end() {
    // TODO: implement
    return {};
  }

private:
  const buffer& _buf;
};

/** Convenience type alias for a buffer_view for accessing a buffer by channels. */
using channel_view = buffer_view<buffer_view_type::channels>;

/** Convenience type alias for a buffer_view for accessing a buffer by frames. */
using frame_view = buffer_view<buffer_view_type::frames>;

_LIBSTDAUDIO_NAMESPACE_END